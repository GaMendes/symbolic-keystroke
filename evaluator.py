import pandas as pd
import numpy as np
import sympy
from typing import Dict, Any, Optional, List
from utils import default_print

class EGPPEvaluator:

    """
    Evaluates symbolic expressions generated by eggp, applies sigmoid, and classifies based on a threshold strategy.
    """

    def __init__(self, expression_string: str, logger=None):

        """
        Initializes the evaluator by parsing the expression string.

        Args:
            expression_string: The mathematical expression string f(x)
                               (e.g., "(+ (* x0 1.5) x1)"). Assumes variables
                               x0, x1, ..., x30 correspond to feature columns
                               in the order they appear in the input dataframes.
        """

        self.logger   = logger
        self._info    = self.logger.info if self.logger else default_print
        self._error   = self.logger.error if self.logger else default_print
        self._warning = self.logger.warning if self.logger else default_print

        self.expression_string = expression_string
        self._lambdified_fx = None
        self._variables: List[sympy.Symbol] = []
        self._parse_and_lambdify()

    def _parse_and_lambdify(self):

        """Parses the expression string and creates a numerical function."""

        try:
            # Assume variables are x0, x1, ..., x30 (31 features)
            self.feature_count = 31 # Hardcoding baseando-se em conhecimento prévio
            self._variables = [sympy.symbols(f'x{i}') for i in range(self.feature_count)]

            custom_functions = {
                'Recip': lambda x: np.true_divide(1.0, x),
                'PowerAbs': lambda x, y: np.power(np.abs(x), y) 
            }
            expr = sympy.sympify(self.expression_string, locals=custom_functions)

            self._lambdified_fx = sympy.lambdify(self._variables, expr, modules=['numpy', custom_functions])
            self._info(f"Successfully parsed and lambdified expression.", component="EVALUATOR")

        except (SyntaxError, TypeError, NameError, Exception) as e:

            self._error(f"Error parsing or lambdifying expression: '{self.expression_string}'", component="EVALUATOR")
            self._error(f"Error: {e}", component="EVALUATOR")
            self._lambdified_fx = None

    def evaluate_fx(self, features_df: pd.DataFrame) -> Optional[np.ndarray]:

        """
        Evaluates the lambdified f(x) function on the input features.

        Args:
            features_df: DataFrame where columns 0 to N-1 contain the features
                         corresponding to x0 to xN-1 used in the expression.
                         (N = self.feature_count).

        Returns:
            NumPy array of raw f(x) scores, or None if lambdification failed.
        """

        if self._lambdified_fx is None:
            self._error("Error: Expression function is not available.", component="EVALUATOR")
            return None

        if features_df.shape[1] + 1 < self.feature_count:
             self._error(f"Error: Input DataFrame has {features_df.shape[1]} columns, but expression requires {self.feature_count} features (x0-{self.feature_count-1}).", component="EVALUATOR")
             return None

        feature_values = features_df.iloc[:, :self.feature_count].values
        try:
            scores = self._lambdified_fx(*feature_values.T)
            return np.array(scores).flatten()

        except Exception as e:
            self._error(f"Error evaluating function on features: {e}", component="EVALUATOR")
            return None

    def predict_proba(self, features_df: pd.DataFrame) -> Optional[np.ndarray]:

        """
        Calculates the sigmoid probability p = 1 / (1 + exp(-f(x))).

        Args:
            features_df: DataFrame of features.

        Returns:
            NumPy array of probabilities, or None on error.
        """

        scores = self.evaluate_fx(features_df)
        if scores is None:
            return None

        try:

            # Clip scores to prevent overflow/underflow in exp
            clipped_scores = np.clip(scores, -700, 700)
            probabilities = 1 / (1 + np.exp(-clipped_scores))
            return probabilities

        except Exception as e:

            self._error(f"Error calculating sigmoid probabilities: {e}", component="EVALUATOR")
            return None

    def _apply_fixed_threshold(self, probabilities: np.ndarray, threshold_value: float) -> np.ndarray:

        """Applies a fixed threshold to probabilities."""
        return (probabilities >= threshold_value).astype(int)

    def _calculate_adaptive_threshold_placeholder_min(self, train_genuine_scores: np.ndarray) -> float:

        self._warning("Warning: Adaptive threshold 'min' not implemented. Using default.", component="EVALUATOR")
        # Maybe?: threshold = np.min(train_genuine_scores)
        return 0.5 # Default fallback

    def _calculate_adaptive_threshold_placeholder_min_non_outlier(self, train_genuine_scores: np.ndarray) -> float:
    
        self._warning("Warning: Adaptive threshold 'min-non-outlier' not implemented. Using default.", component="EVALUATOR")
        # Maybe?:
        # mean_score = np.mean(train_genuine_scores)
        # std_score = np.std(train_genuine_scores)
        # lower_bound = mean_score - 2.5 * std_score
        # non_outlier_scores = train_genuine_scores[train_genuine_scores > lower_bound]
        # threshold = np.min(non_outlier_scores) if len(non_outlier_scores) > 0 else mean_score # Handle empty case
        return 0.5 # Default fallback

    def predict(self, features_df: pd.DataFrame, threshold_config: Dict[str, Any],
                train_genuine_scores: Optional[np.ndarray] = None) -> Optional[np.ndarray]:

        """
        Generates binary predictions based on the configured threshold strategy.

        Args:
            features_df: DataFrame of features for test data.
            threshold_config: Dictionary with 'strategy' ('fixed', etc.) and 'value' (for fixed strategy).
            train_genuine_scores: Optional NumPy array of raw f(x) scores for
                                  genuine training samples. Required for
                                  adaptive strategies.

        Returns:
            NumPy array of binary predictions (0 or 1), or None on error.
        """

        probabilities = self.predict_proba(features_df)
        if probabilities is None:
            return None

        strategy = threshold_config.get('strategy', 'fixed')
        threshold_value = float(threshold_config.get('value', 0.5))

        self._info(f"  Applying threshold strategy: {strategy}", component="EVALUATOR")

        if strategy == 'fixed':

            final_threshold = threshold_value
            return self._apply_fixed_threshold(probabilities, final_threshold)

        elif strategy == 'adaptive_placeholder_min':

            if train_genuine_scores is None:
                self._error("Error: Adaptive strategy 'min' requires train_genuine_scores.", component="EVALUATOR")
                return None
            # No artigo isso aqui não são probabilidades, talvez temos que pensar em um jeito melhor de implementar isso considerando esse cenário?? 
            final_threshold = self._calculate_adaptive_threshold_placeholder_min(train_genuine_scores)

            self._info(f"  (Placeholder) Adaptive min threshold calculated: {final_threshold:.4f}. Applying to probabilities.", component="EVALUATOR")
            return self._apply_fixed_threshold(probabilities, final_threshold)

        elif strategy == 'adaptive_placeholder_min_non_outlier':

            if train_genuine_scores is None:
                self._error("Error: Adaptive strategy 'min-non-outlier' requires train_genuine_scores.", component="EVALUATOR")
                return None

            final_threshold = self._calculate_adaptive_threshold_placeholder_min_non_outlier(train_genuine_scores)
            # No artigo isso aqui não são probabilidades, talvez temos que pensar em um jeito melhor de implementar isso considerando esse cenário??
            self._info(f"  (Placeholder) Adaptive min-non-outlier threshold calculated: {final_threshold:.4f}. Applying to probabilities.", component="EVALUATOR")
            return self._apply_fixed_threshold(probabilities, final_threshold)

        else:
            self._error(f"Error: Unknown threshold strategy '{strategy}'. Using fixed 0.5.", component="EVALUATOR")
            return self._apply_fixed_threshold(probabilities, 0.5)